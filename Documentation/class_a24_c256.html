<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Portable Radio: A24C256 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Portable Radio
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a24_c256-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">A24C256 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>24C EEPROM Interface  
 <a href="class_a24_c256.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_a24_c256_8hpp_source.html">A24C256.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20b34e7602c015990296fa4fc29c026f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a24_c256.html#a20b34e7602c015990296fa4fc29c026f">A24C256</a> (hwlib::i2c_bus_bit_banged_scl_sda &amp;bus, unsigned int givenMemorySize=256, uint8_t address=0x50)</td></tr>
<tr class="memdesc:a20b34e7602c015990296fa4fc29c026f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constuctor.  <a href="#a20b34e7602c015990296fa4fc29c026f">More...</a><br /></td></tr>
<tr class="separator:a20b34e7602c015990296fa4fc29c026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfaf9ab702ccbf9dee540d42aa3c258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a24_c256.html#abcfaf9ab702ccbf9dee540d42aa3c258">write</a> (unsigned int location, uint8_t value)</td></tr>
<tr class="memdesc:abcfaf9ab702ccbf9dee540d42aa3c258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single Byte Write.  <a href="#abcfaf9ab702ccbf9dee540d42aa3c258">More...</a><br /></td></tr>
<tr class="separator:abcfaf9ab702ccbf9dee540d42aa3c258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800ece6969a73f7ae752c147d61dfbd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a24_c256.html#a800ece6969a73f7ae752c147d61dfbd5">write</a> (unsigned int location, char *value, bool largeBuffer=true)</td></tr>
<tr class="memdesc:a800ece6969a73f7ae752c147d61dfbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi Byte write.  <a href="#a800ece6969a73f7ae752c147d61dfbd5">More...</a><br /></td></tr>
<tr class="separator:a800ece6969a73f7ae752c147d61dfbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b05010340adcfcf11e103336463d7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a24_c256.html#ac48b05010340adcfcf11e103336463d7">read</a> (unsigned int location)</td></tr>
<tr class="memdesc:ac48b05010340adcfcf11e103336463d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single Byte read.  <a href="#ac48b05010340adcfcf11e103336463d7">More...</a><br /></td></tr>
<tr class="separator:ac48b05010340adcfcf11e103336463d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c838b32fe083964150970637986a5a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a24_c256.html#a90c838b32fe083964150970637986a5a">read</a> (unsigned int location, unsigned int length, uint8_t receivedData[]={})</td></tr>
<tr class="memdesc:a90c838b32fe083964150970637986a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi Byte read.  <a href="#a90c838b32fe083964150970637986a5a">More...</a><br /></td></tr>
<tr class="separator:a90c838b32fe083964150970637986a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefd871dd8be8e088f34557132f66c0b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a24_c256.html#adefd871dd8be8e088f34557132f66c0b">getAddress</a> ()</td></tr>
<tr class="memdesc:adefd871dd8be8e088f34557132f66c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C address.  <a href="#adefd871dd8be8e088f34557132f66c0b">More...</a><br /></td></tr>
<tr class="separator:adefd871dd8be8e088f34557132f66c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbef3fc6194ceb09a0ae7ce9830f3bd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a24_c256.html#a3dbef3fc6194ceb09a0ae7ce9830f3bd">getMemorySize</a> ()</td></tr>
<tr class="memdesc:a3dbef3fc6194ceb09a0ae7ce9830f3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Memory Size.  <a href="#a3dbef3fc6194ceb09a0ae7ce9830f3bd">More...</a><br /></td></tr>
<tr class="separator:a3dbef3fc6194ceb09a0ae7ce9830f3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>24C EEPROM Interface </p>
<p>This is an interface that simplifies writing to and reading from 24CXXXX EEPROM chips. Completely compatible with 24C24C32, 24C64, 24C128, 24C256, 24C512 and 24C1024. It is possible to write and read single bytes (chars, bools, integers) and multi-byte values (char[]). By default , the chip is unable to write multi-byte values accross multiple pages. However, this is dealt with from within this library.</p>
<p>All supported operations are:</p><ul>
<li>Write Single Byte</li>
<li>Write Multiple Bytes</li>
<li>Read Single Byte</li>
<li>Read Multiple Bytes</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;hwlib.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_a24_c256_8hpp.html">A24C256.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="24_c256_2_tests_2main_8cpp.html#a840291bc02cba5474a4cb46a9b9566fe">main</a>( <span class="keywordtype">void</span> ){</div><div class="line">    <span class="keyword">namespace </span>target = hwlib::target; </div><div class="line"></div><div class="line">    <span class="keyword">auto</span> scl = target::pin_oc( target::pins::d8 );</div><div class="line">    <span class="keyword">auto</span> sda = target::pin_oc( target::pins::d9 );</div><div class="line">    <span class="keyword">auto</span> i2c_bus = hwlib::i2c_bus_bit_banged_scl_sda(scl, sda);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> memory = <a class="code" href="class_a24_c256.html#a20b34e7602c015990296fa4fc29c026f">A24C256</a>(i2c_bus);</div><div class="line">    <span class="keyword">auto</span> largeMemory = <a class="code" href="class_a24_c256.html#a20b34e7602c015990296fa4fc29c026f">A24C256</a>(i2c_bus, 512);</div><div class="line"></div><div class="line">    <span class="comment">//Write one single byte at location 0 and retrieve it</span></div><div class="line">    memory.write(0, <span class="charliteral">&#39;c&#39;</span>);</div><div class="line">    hwlib::cout &lt;&lt; char(memory.read(0)) &lt;&lt; hwlib::endl;</div><div class="line"></div><div class="line">    <span class="comment">//Write 12 bytes to location 20</span></div><div class="line">    <span class="keywordtype">char</span> data[]={<span class="stringliteral">&quot;Hello World!&quot;</span>};</div><div class="line">    memory.write(20, data);</div><div class="line"></div><div class="line">    <span class="comment">//Retrieve multiple bytes (preffered)</span></div><div class="line">    uint8_t receivedData[12];</div><div class="line">    memory.read(20, 12, receivedData);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 12; i++){</div><div class="line">        hwlib::cout &lt;&lt; char(receivedData[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    hwlib::cout &lt;&lt; hwlib::endl;</div><div class="line"></div><div class="line">    <span class="comment">//Another way to retrieve multiple bytes</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 20; i &lt; 32; i++){</div><div class="line">        hwlib::cout &lt;&lt; char(memory.read(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    hwlib::cout &lt;&lt; hwlib::endl;</div><div class="line"></div><div class="line">    memory.write(0, 100);</div><div class="line">    hwlib::cout &lt;&lt; memory.read(0) &lt;&lt; hwlib::endl;</div><div class="line"></div><div class="line">    memory.write(0, <span class="keyword">true</span>);</div><div class="line">    hwlib::cout &lt;&lt; (bool(memory.read(0)) &amp;&amp; 1);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a20b34e7602c015990296fa4fc29c026f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b34e7602c015990296fa4fc29c026f">&#9670;&nbsp;</a></span>A24C256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">A24C256::A24C256 </td>
          <td>(</td>
          <td class="paramtype">hwlib::i2c_bus_bit_banged_scl_sda &amp;&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>givenMemorySize</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em> = <code>0x50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constuctor. </p>
<p>This constructor has one mandatory parameter; the I2C bus. The Address defaults to 0x50. The memorysize defaults to 256Kb. Changing this makes the use of other 24CXXXX chips possible. If an illegal amount of memory is given, the constructor will change the memory size to a valid size by determining which valid size is closest to the given one. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adefd871dd8be8e088f34557132f66c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefd871dd8be8e088f34557132f66c0b">&#9670;&nbsp;</a></span>getAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t A24C256::getAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C address. </p>
<p>This function returns the set I2C address of the chip. </p>

</div>
</div>
<a id="a3dbef3fc6194ceb09a0ae7ce9830f3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbef3fc6194ceb09a0ae7ce9830f3bd">&#9670;&nbsp;</a></span>getMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int A24C256::getMemorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Memory Size. </p>
<p>This function returns the set memory size of the chip. </p>

</div>
</div>
<a id="ac48b05010340adcfcf11e103336463d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48b05010340adcfcf11e103336463d7">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t A24C256::read </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single Byte read. </p>
<p>This function takes one mandatory parameter; the location. If the location is valid, it returns the value that is currently saved at the desired position. Otherwise, it returns 0 to emphasize failure. </p>

</div>
</div>
<a id="a90c838b32fe083964150970637986a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c838b32fe083964150970637986a5a">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t A24C256::read </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>receivedData</em>[] = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi Byte read. </p>
<p>This function takes a couple of arguments. The location is the address where to start reading from. The length is the amount of bytes to read and receivedData is the variable to store data in. If the location is valid, the data will be returned. Otherwise 0 will be returned to emphasize failure. </p>

</div>
</div>
<a id="abcfaf9ab702ccbf9dee540d42aa3c258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfaf9ab702ccbf9dee540d42aa3c258">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void A24C256::write </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single Byte Write. </p>
<p>This function takes two mandatory parameters; location and value. The location has to be valid for the value to be written. The location is divided in two parts; MSB and LSB. The location and value are written at once. It takes 5ms for the EEPROM to become responsive again. Waiting these 5ms prevents weird things from happening. </p>

</div>
</div>
<a id="a800ece6969a73f7ae752c147d61dfbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800ece6969a73f7ae752c147d61dfbd5">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void A24C256::write </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>largeBuffer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi Byte write. </p>
<p>This function takes a couple of arguments. The location is the address where the start of the value to be saved is going to be written. The value is going to be saved (beginning at location) and largeBuffer defines if the buffer is 64 or 32 bytes. If the location is valid, the data will be written.</p>
<p>Buffer A Buffer-size of 64 bytes is faster and more efficient. Though not all microcontrollers or I2C libraries can handle this. To make this library user-friendly you can choose which one to use.</p>
<p>Pages The memory consists of pages of 64 bytes each. When an edge of a page is reached, the write process will continue at the beginning of this current page; thus overwriting data. To prevent that from happening, we monitor when this will happen. We'll write multiple bytes of amount 'pageSize' or as much that will fit in the current page. If there is data left, we'll write that to the next page. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_a24_c256_8hpp_source.html">A24C256.hpp</a></li>
<li><a class="el" href="_a24_c256_8cpp.html">A24C256.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 2 2019 12:04:42 for Portable Radio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
